$(document).ready(function() {
  
    let app = ThreeUtils.setupApp();
  
    let scene = app.scene;
  
    var objects = [];
    var sceneobjects = new THREE.Group();
    sceneobjects.position.set(15,0,0)
    app.scene.add(sceneobjects);
    var spheregeom = new THREE.SphereGeometry(10, 32, 32);
    var bluemat = new THREE.MeshPhongMaterial({color: 0x6666ff});
    bluemat.side = THREE.DoubleSide;
    spheregeom.mat = bluemat;
    var sphere = new THREE.Mesh(spheregeom, spheregeom.mat.clone());
    sphere.name = "sphere";
    sceneobjects.add(sphere);
    objects.push(sphere);
  
    var cubegeom = new THREE.CubeGeometry(15,15,15);
    var redmat = new THREE.MeshPhongMaterial({color: 0xff6666});
    redmat.side = THREE.DoubleSide;
    cubegeom.mat = redmat;
    var cube = new THREE.Mesh(cubegeom, cubegeom.mat.clone());
    cube.name = "cube";
    sceneobjects.add(cube);
    objects.push(cube);
  
    var cylgeom = new THREE.CylinderGeometry(5,5,20,32,1);
    var greenmat = new THREE.MeshPhongMaterial({color: 0x66ff66});
    greenmat.side = THREE.DoubleSide;
    cylgeom.mat = greenmat;
    var cyl = new THREE.Mesh(cylgeom, cylgeom.mat.clone());
    cyl.name = "cyl";
    cyl.negative = true;
    sceneobjects.add(cyl);
    objects.push(cyl);
  
    var cyl2 = new THREE.Mesh(cylgeom, cylgeom.mat.clone());
    cyl2.setRotationFromAxisAngle(new THREE.Vector3(1,0,0), Math.PI/2);
    cyl2.name = "cyl2";
    cyl2.negative = true;
    sceneobjects.add(cyl2);
    objects.push(cyl2);
  
      var cyl3 = new THREE.Mesh(cylgeom, cylgeom.mat.clone());
    cyl3.setRotationFromAxisAngle(new THREE.Vector3(0,0,1), Math.PI/2);
    cyl3.name = "cyl3";
    cyl3.negative = true;
    sceneobjects.add(cyl3);
    objects.push(cyl3);  
    
    var cubeCsg = THREE.CSG.toCSG(cubegeom).setColor([1,0,0]);
    var resultCsg = cubeCsg;
     var sphereCsg	= THREE.CSG.toCSG(spheregeom);
     resultCsg	= resultCsg.intersect(sphereCsg);  
     resultCsg	= resultCsg.subtract(THREE.CSG.toCSG(cyl));  
     resultCsg	= resultCsg.subtract(THREE.CSG.toCSG(cyl2));  
     resultCsg	= resultCsg.subtract(THREE.CSG.toCSG(cyl3));  
  
  //  resultCsg = resultCsg.stretchAtPlane([0,0,1], [0,0,0], 4);
  //  resultCsg = resultCsg.cutByPlane( CSG.Plane.fromNormalAndPoint([1,1,1], [0,0,0]));
    
    
    var resultGeo	= THREE.CSG.fromCSG( resultCsg);
  var material	= new THREE.MeshLambertMaterial( { color: 0xaaaaaa,} );
    var mesh = new THREE.Mesh( resultGeo, material);
    mesh.position.set(-15,0,0)
      scene.add(mesh);  
    
    app.camera.position.set(50,50,50);
    app.camera.lookAt(new THREE.Vector3(0, 0, 0));
    
    ThreeUtils.animate();
  });
  
   
  /*
      THREE.CSG
      @author Chandler Prall <chandler.prall@gmail.com> http://chandler.prallfamily.com
      
      Wrapper for Evan Wallace's CSG library (https://github.com/evanw/csg.js/)
      Provides CSG capabilities for Three.js models.
      
      Provided under the MIT License
  */
  
  THREE.CSG = {
      toCSG: function ( three_model ) {
          var i, geometry, polygons, vertices;
          
          if ( !CSG ) {
              throw 'CSG library not loaded. Please get a copy from https://github.com/evanw/csg.js';
          }
          
          if ( three_model instanceof THREE.Mesh ) {
        geometry = new THREE.Geometry();
        geometry.mergeMesh(three_model);
          } else if ( three_model instanceof THREE.Geometry ) {
              geometry = three_model;
          } else {
              throw 'Model type not supported.';
          }
          
          var polygons = [];
          for ( i = 0; i < geometry.faces.length; i++ ) {
              if ( geometry.faces[i] instanceof THREE.Face3 ) {
                  vertices = [
  new CSG.Vertex(new CSG.Vector3D(geometry.vertices[geometry.faces[i].a])),
  new CSG.Vertex(new CSG.Vector3D(geometry.vertices[geometry.faces[i].b])),
  new CSG.Vertex(new CSG.Vector3D(geometry.vertices[geometry.faces[i].c]))];
                  polygons.push( new CSG.Polygon( vertices ) );
              } else if ( geometry.faces[i] instanceof THREE.Face4 ) {
                  vertices = [
  new CSG.Vertex(new CSG.Vector3D(geometry.vertices[geometry.faces[i].a])),
  new CSG.Vertex(new CSG.Vector3D(geometry.vertices[geometry.faces[i].b])),
  new CSG.Vertex(new CSG.Vector3D(geometry.vertices[geometry.faces[i].d]))];
                  polygons.push( new CSG.Polygon( vertices ) );
                  vertices = [
  new CSG.Vertex(new CSG.Vector3D(geometry.vertices[geometry.faces[i].b])),
  new CSG.Vertex(new CSG.Vector3D(geometry.vertices[geometry.faces[i].c])),
  new CSG.Vertex(new CSG.Vector3D(geometry.vertices[geometry.faces[i].d]))];
                  polygons.push( new CSG.Polygon( vertices ) );
              } else {
                  throw 'Model contains unsupported face.';
              }
          }
          
          return CSG.fromPolygons( polygons );
      },
      
      fromCSG: function( csg_model ) {
          var i, j, vertices, face,
              three_geometry = new THREE.Geometry( ),
              polygons = csg_model.toPolygons( );
          
          if ( !CSG ) {
              throw 'CSG library not loaded. Please get a copy from https://github.com/evanw/csg.js';
          }
          
          for ( i = 0; i < polygons.length; i++ ) {
              
              // Vertices
              vertices = [];
              for ( j = 0; j < polygons[i].vertices.length; j++ ) {
                  vertices.push( this.getGeometryVertice( three_geometry, polygons[i].vertices[j].pos ) );
              }
              if ( vertices[0] === vertices[vertices.length - 1] ) {
                  vertices.pop( );
              }
              
              for (var j = 2; j < vertices.length; j++) {
                  face = new THREE.Face3( vertices[0], vertices[j-1], vertices[j], new THREE.Vector3( ).copy( polygons[i].plane.normal ) );
                  three_geometry.faces.push( face );
                  //three_geometry.faceVertexUvs[0].push( new THREE.UV( ) );
              }
          }
          
          three_geometry.computeBoundingBox();
          
          return three_geometry;
      },
      
      getGeometryVertice: function getGeometryVertice ( geometry, vertice_position ) {
          //var i;
          //for ( i = 0; i < geometry.vertices.length; i++ ) {
          //	if ( geometry.vertices[i].position.x === vertice_position.x
          //		&& geometry.vertices[i].position.y === vertice_position.y
          //		&& geometry.vertices[i].position.z === vertice_position.z ) {
          //		// Vertice already exists
          //		return i;
          //	}
          //};
          
          geometry.vertices.push(new THREE.Vector3( vertice_position.x, vertice_position.y, vertice_position.z ) );
          return geometry.vertices.length - 1;
      }
  };
  
  